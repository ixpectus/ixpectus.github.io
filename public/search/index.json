[{"content":"","href":"/posts/storage/","title":"storage"},{"content":"","href":"/posts/administrate/","title":"administrate"},{"content":"","href":"/posts/linux/tools/","title":"linux tools"},{"content":"","href":"/","title":"ixpectus notes"},{"content":"","href":"/posts/storage/postgresql/","title":"postgresql"},{"content":"","href":"/posts/","title":"posts"},{"content":" Демо Слайды  Буфферный кэш Процесс работы с диском выглядит как-то так\n Postrges понимает, что нужны какие-то данные с диска Postrges идёт сначала в некий кэш, в который помещает страницы после чтения с диска(буфферный кэш) Если данные в кэше есть, то они берутся из кэша, если в кэше данных нет, то они берутся с диска и помещаются в кэш Получить данные из кэша дешевле чем с диска, но поскольку кэш находится в общей памяти, то его необходимо защищать блокировками, и поэтому взять данные из кэша медленнее, чем просто из памяти После изменения данные также записываются сначала в буфферный кэш Фоновый процесс периодически записывает данные из буфферного кэша на диск(работает вытеснение LRU)  WAL В случае сбоя данные из буфферного кэша могут потеряться, и если ничего не предпринять, то они исчезнут насовсем. Решение - WAL Как и в других БД в postrgesql присутствует WAL(Write Ahead Log). Сначала данные попадают в него, а уже потом в файл с данными. Казалось бы почему сразу не записать данные в файл с данными. Пишут в WAL, т.к. это гораздо быстрее, запись делается просто в конец файла, это работает быстро как на SSD, так и на HDD. WAL прежде всего нужен для восстановления после сбоя. И когда данные уже оказались на диске в файле с данными, то их из WAL можно удалять. За это отвечает checkpointer process, а за запись в WAL отвечает wal writer process\nРежимы работы WAL В случае, если данные записались в WAL не факт, что они реально попадут на диск, т.к. есть ещё кэш операционной системы. Для того, чтобы данные попали на диск нужно сделать системный вызов fsync, и тут есть 2 вариант\n Синхронный - fsync делается при каждой записи в WAL Асинхронный - fsync делается периодические процессом wal writer process, это менее надёжно, но быстрее  Checkpointer process(контрольная точка) Проблема - если ничего не предпринимать, то WAL вырастет до огромных размеров и нужно будет каждый раз перечитывать его весь при сбоях. Решение - сохранять некие контрольные точки(в каком только виде) для журнала, в которых все данные с журнала уже есть на диске. Периодически все данные из буфферов полностью записываются на диск и создаётся контрольная точка. Это делает checkpointer process. Если бы данные на диск записывал только этот процесс, то работал бы очень долго. Есть ещё writer process, которые записывает на диск страницы, которые должны вытеснится\nLSN Каждая запись в журнале имеет номер LSN (Log Sequence Number).\nSELECT pg_current_wal_lsn(); pg_current_wal_lsn -------------------- 0/2823EA8 (1 row) Можно посмотреть, как меняется этот номер при вставке каких-нибудь данных\n Сохраним текущий lsn 127.0.0.1 postgres@test=# SELECT pg_current_wal_lsn() AS pos1 \\gset Time: 0.586 ms 127.0.0.1 postgres@test=# select :'pos1'::pg_lsn; pg_lsn ----------- 0/2826B70 (1 row)  Вставим данные и посмотрим на новый lsn insert into some_table(id) values(3); INSERT 0 1 Time: 2.196 ms 127.0.0.1 postgres@test=# SELECT pg_current_wal_lsn() AS pos2 \\gset Time: 0.602 ms 127.0.0.1 postgres@test=# select :'pos2'::pg_lsn; pg_lsn ----------- 0/2826DD8 (1 row) Time: 0.579 ms 127.0.0.1 postgres@test=# SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn; ?column? ---------- 616 (1 row) Видно, что разница в записях 616 байт\n  Также можно что-то узнать о журналах, сделав запрос\nSELECT * FROM pg_ls_waldir() ORDER BY name; name | size | modification --------------------------+----------+------------------------ 000000010000000000000002 | 16777216 | 2020-06-24 10:41:37+03 000000010000000000000003 | 16777216 | 2020-06-23 10:51:02+03 (2 rows) ","href":"/posts/storage/postgresql/cache/","title":"Буфферный кэш"},{"content":"","href":"/tags/acid/","title":"acid"},{"content":"","href":"/tags/isolation/","title":"isolation"},{"content":"","href":"/tags/mvcc/","title":"mvcc"},{"content":"","href":"/tags/postgresql/","title":"postgresql"},{"content":"","href":"/tags/","title":"Tags"},{"content":" Демо Слайды  MVCC и postrges Для того, чтобы писатели не блокировали читателей в postgres используется MVCC - multiversion concurrency control. Клиент может читать данные, пока кто-то другой эти данные меняет. Каждое изменение строки приводит к появлению новой версии строки в файле данных. Каждый запрос работает со снимком данных. Снимок включает в себя\n номер последней активной транзакции список активных транзакций Список активных транзакций нужен для того, чтобы случайно не считать данные, которые находятся ещё в процессе изменения  Vacuum Каждое изменение данных приводит к появлению новой строки данных. Кажется, что изменение одного int может привести к появлению новой строки, в которой потенциально может быть гораздо больше данных.\nСо временем данные становятся никому не нужно, поскольку нет процессов, которые работают со снимком, включающих в себя эти данные.\nУдалением неактуальных данных занимается процесс auto vacuum, а точнее 2 процесса\n autovacuum launcher следит за количеством строк, которые надо удалить и при необходимости вызвает autovacuum worker непосредственно занимается удалением неактуальных данных  Команды  SELECT txid_current(); возвращает id текущей транзакции, что интересно, каждый следующий вызов увеличивает число select xmax, xmin from \u0026lt;table_name\u0026gt; можно увидеть значения xmax и xmin для строк в таблице  xmin минимальный номер транзакции, для которой актуальна эта версия строки xmax максимальный номер транзакции, для которой актуальна эта версия строки    Поэкспериментируем  Создадим базу и таблицу  create database test; create table texts(s1 text,s2 text);  Посмотрим xmin, xmax 127.0.0.1 postgres@test=# select xmax,xmin from texts; xmax | xmin ------+------ (0 rows) Ничего нет, что логично\n Вставим строку и посмотрим на xmin, xmax 127.0.0.1 postgres@test=# insert into texts(s1,s2) values('qqq', 'wwwwwww'); INSERT 0 1 127.0.0.1 postgres@test=# select *, xmin, xmax from texts; s1 | s2 | xmin | xmax -----+---------+------+------ qqq | wwwwwww | 565 | 0 (1 row) xmin установлен, а xmax = 0, что говорит о том, что данные актуальны\n Обновим строку и снова посмотрим 127.0.0.1 postgres@test=# update texts set s2='wwwwww' where s1='qqq'; UPDATE 1 Time: 1.329 ms 127.0.0.1 postgres@test=# select *, xmin, xmax from texts; s1 | s2 | xmin | xmax -----+--------+------+------ qqq | wwwwww | 566 | 0 (1 row) Time: 0.626 ms Видно, что версия обновилась, но старых данных не видно, интересно\n Попробуем в 2-х терминалах  Терминал 1 127.0.0.1 postgres@test=# begin transaction; BEGIN Time: 0.364 ms 127.0.0.1 postgres@test=# select *, xmin, xmax from texts; s1 | s2 | xmin | xmax -----+--------+------+------ qqq | wwwwww | 566 | 0 (1 row) Time: 0.564 ms 127.0.0.1 postgres@test=# update texts set s2='yyy' where s1='qqq'; UPDATE 1 Time: 0.627 ms 127.0.0.1 postgres@test=# select *, xmin, xmax from texts; s1 | s2 | xmin | xmax -----+-----+------+------ qqq | yyy | 567 | 0 (1 row) Time: 0.481 ms  Терминал 2 begin transaction; 127.0.0.1 postgres@test=# select *, xmin, xmax from texts; s1 | s2 | xmin | xmax -----+--------+------+------ qqq | wwwwww | 566 | 567 (1 row) select txid_current(); txid_current -------------- 568     В 1 терминале начали транзакцию, изменили значение и прошлого значения там уже не видно. А вот во втором терминале видно, что xmax=567, что говорит о том, что значение уже неактуально, но в первой транзакции ещё не было коммита. После того, как в первой сессии произойдёт commit, появится возможность прочитать обновленные данные.\n Что будет, если в первом терминале сделать rollback ? Я предположил, что в этом случае появится новая версия строки с большим xmin и xmax=0, но в первом терминале после rollback я увидел следующее  127.0.0.1 postgres@test=# update texts set s2='zzz' where s1='qqq'; UPDATE 1 Time: 0.228 ms 127.0.0.1 postgres@test=# rollback; ROLLBACK Time: 0.187 ms 127.0.0.1 postgres@test=# select * , xmin, xmax from texts; s1 | s2 | xmin | xmax -----+-----+------+------ qqq | yyy | 567 | 569 (1 row) В момент выполнения этого запроса во втором терминале\n127.0.0.1 postgres@test=# select txid_current(); txid_current -------------- 568 (1 row) После rollback во втором терминале xmin и xmax не изменились. Не очень понятно, что значит xmax в таком случае\nУровни изоляции транзакций  Read Commited Repeatable Read Serializable  Можно установить уровень транзакции при старте транзакции\nbegin isolation level repeatable read; Эксперимент со счётчиком Судя по тому, что я узнал если сделать таблицу с одной строчкой и 10 тысяч раз её изменить, то размер таблицы увеличится, проверим\n Создадим таблицу и вставим строку  127.0.0.1 postgres@test=# create table some_table(id int, counter int, text1 text, text2 text); CREATE TABLE Time: 12.475 ms 127.0.0.1 postgres@test=# insert into some_table(id, counter, text1, text2) values(1,0,'qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq','wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww'); INSERT 0 1 Time: 2.613 ms  Посмотрим размер таблицы  127.0.0.1 postgres@test=# SELECT pg_size_pretty( pg_total_relation_size('some_table') ); pg_size_pretty ---------------- 16 kB (1 row)  Посмотрим файлы на диске  ixpectus# ls -lh $PGDATA 6 postgres postgres 4.0K Jun 21 22:06 base drwx------ 2 postgres postgres 4.0K Jun 21 22:08 global drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_commit_ts drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_dynshmem -rw------- 1 postgres postgres 4.5K Jun 16 10:42 pg_hba.conf -rw------- 1 postgres postgres 1.6K Jun 16 10:42 pg_ident.conf drwx------ 4 postgres postgres 4.0K Jun 23 10:23 pg_logical drwx------ 4 postgres postgres 4.0K Jun 16 10:42 pg_multixact drwx------ 2 postgres postgres 4.0K Jun 21 13:40 pg_notify drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_replslot drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_serial drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_snapshots drwx------ 2 postgres postgres 4.0K Jun 21 13:40 pg_stat drwx------ 2 postgres postgres 4.0K Jun 23 10:25 pg_stat_tmp drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_subtrans drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_tblspc drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_twophase -rw------- 1 postgres postgres 3 Jun 16 10:42 PG_VERSION drwx------ 3 postgres postgres 4.0K Jun 16 10:42 pg_wal drwx------ 2 postgres postgres 4.0K Jun 16 10:42 pg_xact -rw------- 1 postgres postgres 106 Jun 20 22:25 postgresql.auto.conf -rw------- 1 postgres postgres 23K Jun 20 22:31 postgresql.conf -rw------- 1 postgres postgres 30 Jun 20 22:34 postmaster.opts -rw------- 1 postgres postgres 81 Jun 21 13:40 postmaster.pid  Увеличим counter 10000 раз  for i in {01..10000}; do psql -h 127.0.0.1 -d test -c 'update some_table set counter=counter+1 where id=1';done;  Размер таблицы не изменился практически  127.0.0.1 postgres@test=# SELECT pg_size_pretty( pg_total_relation_size('some_table') ); pg_size_pretty ---------------- 16 kB (1 row) Хотя казалось бы для каждого update должна была создаваться запись с новой версией. Возможно vacuum успевал работать\nРазмер файлов на диске также существенно не изменился\n Попробуем запустить скрипт немного по-другому   for i in {01..10000}; do psql -h 127.0.0.1 -d test -c 'update some_table set counter=counter+1 where id=1' \u0026amp;;done; В конце команды добавил знак \u0026amp;, что приведёт к тому, что команды начнут запускаться не последовательно, а параллельно\n127.0.0.1 postgres@test=# SELECT pg_size_pretty( pg_total_relation_size('some_table') ); pg_size_pretty ---------------- 1008 kB (1 row) И размер базы вырос в 1000 раз, хотя там по-прежнему одна строка\n Теперь увеличим счётчик еще на 10000 раз и посмотрим, какие файлы на диске изменились по размеру\nТекущее состояние  du -h | sort -h 4.0K ./pg_commit_ts 4.0K ./pg_dynshmem 4.0K ./pg_logical/mappings 4.0K ./pg_logical/snapshots 4.0K ./pg_replslot 4.0K ./pg_serial 4.0K ./pg_snapshots 4.0K ./pg_stat 4.0K ./pg_tblspc 4.0K ./pg_twophase 4.0K ./pg_wal/archive_status 12K ./pg_multixact/members 12K ./pg_multixact/offsets 12K ./pg_notify 12K ./pg_xact 16K ./pg_logical 28K ./pg_multixact 32K ./pg_stat_tmp 92K ./pg_subtrans 584K ./global 7.1M ./base/1 7.1M ./base/12296 7.2M ./base/12297 8.2M ./base/16384 17M ./pg_wal 30M ./base После увеличения счётчика на 10000 раз размер базы не увеличился, т.к. вероятно пришёл vacuum и удалил старые строки. Увеличим сразу на 20000. Размер базы вообще уменьшился и размер файлов тоже существенно не увеличился\n127.0.0.1 postgres@test=# SELECT pg_size_pretty( pg_total_relation_size('some_table') ); pg_size_pretty ---------------- 280 kB (1 row) Мораль В postgresql всё работает не так прямолинейно, и даже если размер таблицы увеличился по размеру, он может стать меньше даже без vacuum full\n","href":"/posts/storage/postgresql/isolation/","title":"Изоляция и многоверсионность в postgresql"},{"content":" Слайды  Описание устройства в целом В целом, как и у любой бд есть\n клиент сервер протокол взаимодействия клиента и сервера сервер умеет  разбирать запрос формировать план выполнения выполнять запрос    Интересные нюансы postgresql  postgresql создаёт по процессу на каждое клиентское соединение если клиент решит использовать подготовленный запрос(prepared statement), то он может это сделать и его prepared statement должен будет обработать именно созданный под этого клиента процесс место, необходимое для выполнения запроса(план запроса, prepared statement, позиция курсора) хранится в памяти порождённого обслуживающего процесса. Это важный момент. Дело в том, что postgresql не очень хорошо обрабатывает большое количество соединений и вместе с ним как правило используют некое proxy, которое держит пул коннектов к postgresql. Это приводит к тому, что использовать prepared statement становится затруднительно, т.к. приложение при следующем запросе может быть обслужено другим соединением из пула соединений, которое ничего не знает о его прошлом запросе  Основные процессы в postgresql Работу postgresql обеспечивает ряд процессов ОС\nПосмотрим, что это за процессы \u0026gt; ps -axo pid,ppid,command | grep post 1295940 1283863 vim /usr/local/psql/data/postgresql.conf 1310877 1 /usr/local/pgsql/bin/postgres 1310879 1310877 postgres: checkpointer process 1310880 1310877 postgres: writer process 1310881 1310877 postgres: wal writer process 1310882 1310877 postgres: autovacuum launcher process 1310883 1310877 postgres: stats collector process 1310884 1310877 postgres: bgworker: logical replication launcher 1311013 1310877 postgres: postgres postgres 127.0.0.1(48512) idle По названию можно предположить, что\n /ust/local/psql/bin/postgres основной процесс, который породил остальные процессы, видно что parent id у них 1310877 wal writer process отвечает за запись данных в write ahead log autovacuum launcher process запускает процесс autovacuum(очистки устаревших данных) stats collector process видимо отвечает за сбор статистики, которая в дальнейшем будет использоваться при построении плана выполнения запроса ради интереса убьём процесс autovacuum launcher process и посмотрим что сделает основной процесс postgres ~ sudo kill -9 1310882 ~ ps -axo pid,ppid,command | grep post 1295940 1283863 vim /usr/local/psql/data/postgresql.conf 1310877 1 /usr/local/pgsql/bin/postgres 1355751 1310877 postgres: checkpointer process 1355752 1310877 postgres: writer process 1355753 1310877 postgres: wal writer process 1355754 1310877 postgres: autovacuum launcher process 1355755 1310877 postgres: stats collector process Видно, что postgres перезапустил все остальные процессы(это понятно по сменившимся pid)\n  Описание основных процессов  postmaster самый главный процесс  порождает остальные процессы и следит за ними. В случае, если какой-то процесс аварийно завершает работу, то он может перезапустить как один процесс, так и вообще все процессы(что было видно выше) выделяет общую память, к которой могут получить доступ другие процессы слушает входящие соединения клиентов и порождает процессы, который будут обрабатывать клиентские запросы, эти порожденные запросы выглядят так в команде ps  1370265 1310877 postgres: postgres postgres 127.0.0.1(52834) idle   Процессы обработчики запросов На каждое подключение клиента postgres создаёт отдельный процесс, который обслуживает этого клиента. До определённого момента(говорят до тысячи соединений) это работает неплохо, но больше postgresql не тянет и используют сторонние решения, которые держат пул коннектов к базе и управляют им (например pgbouncer)\nMVCC Postgres использует multi version concurrency control для консистентной работы множества процессов с одними и теми же данными. Клиент в момент подключения получает некий идентификатор транзакции и при чтении получает записи из таблиц, соответствующие этому идентификатору. Т.е. postgres хранит сразу несколько версий строк, при каждом изменении создаётся новая версия строки И в какой-то момент нужно удалять версии строк, который никому не нужны, за это как раз отвечает процесс autovacuum\nКэширование Postgresql кэширует данные в памяти, а с диском работает через системные вызовы OS, и эти системные вызовы используют кэш ОС. Т.е. фактически получается двойной кэш, этим postgresql отличается от MySQL, которые не использует кэш ОС\n","href":"/posts/storage/postgresql/basestructure/","title":"Общее устройство postgresql"},{"content":"","href":"/tags/%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0/","title":"архитектура"},{"content":" Демо Слайды  Посмотреть настройки конфигурационного файла Можно прямо в postgres, есть табличка, которая соответствует конфигурационному файлу\nselect * from pg_file_settings; sourcefile | sourceline | seqno | name | setting | applied | error --------------------------------------+------------+-------+----------------------------+--------------------+---------+-------- /usr/local/psql/data/postgresql.conf | 64 | 1 | max_connections | 100 | t | [NULL] /usr/local/psql/data/postgresql.conf | 113 | 2 | shared_buffers | 128MB | t | [NULL] /usr/local/psql/data/postgresql.conf | 127 | 3 | dynamic_shared_memory_type | posix | t | [NULL] /usr/local/psql/data/postgresql.conf | 461 | 4 | log_timezone | Europe/Moscow | t | [NULL] /usr/local/psql/data/postgresql.conf | 565 | 5 | datestyle | iso, mdy | t | [NULL] /usr/local/psql/data/postgresql.conf | 567 | 6 | timezone | Europe/Moscow | t | [NULL] /usr/local/psql/data/postgresql.conf | 580 | 7 | lc_messages | en_US.UTF-8 | t | [NULL] /usr/local/psql/data/postgresql.conf | 582 | 8 | lc_monetary | en_US.UTF-8 | t | [NULL] /usr/local/psql/data/postgresql.conf | 583 | 9 | lc_numeric | en_US.UTF-8 | t | [NULL] /usr/local/psql/data/postgresql.conf | 584 | 10 | lc_time | en_US.UTF-8 | t | [NULL] /usr/local/psql/data/postgresql.conf | 587 | 11 | default_text_search_config | pg_catalog.english | t | [NULL] (11 rows) Столбец applied везде установлен true, что говорит о том, что в конфигурационном файле значение установлено, но в текущей сессии вполне может быть другое значение этого параметра.\nГде посмотреть конфигурационные параметры текущей сессии  Посмотреть все текущие настройки(там много всего) select * from pg_settings;  Узнать имя текущего конфигурационного файла select * from pg_settings where name='config_file'; -[ RECORD 1 ]---+------------------------------------------- name | config_file setting | /usr/local/psql/data/postgresql.conf unit | [NULL] category | File Locations short_desc | Sets the server's main configuration file. extra_desc | [NULL] context | postmaster vartype | string source | override min_val | [NULL] max_val | [NULL] enumvals | [NULL] boot_val | [NULL] reset_val | /usr/local/psql/data/postgresql.conf sourcefile | [NULL] sourceline | [NULL] pending_restart | f Видим, что файл расположен в /usr/local/psql/data/postgresql.conf\n setting текущее значение параметра reset_val значение по умолчанию, если выполнить команду reset то оно будет установлено pending_restart обозначает необходимость перезапуска сервера для того, чтобы конфигурационный параметр применился(в нашей случае false, значит перезагружать сервер нет необходимости)   Узнать значение параметра work_mem - максимальное количество памяти, которое может быть выделено для текущего процесса  select * from pg_settings where name='work_mem'\\gx -[ RECORD 1 ]---+---------------------------------------------------------------------------------------------------------------------- name | work_mem setting | 4096 unit | kB category | Resource Usage / Memory short_desc | Sets the maximum memory to be used for query workspaces. extra_desc | This much memory can be used by each internal sort operation and hash table before switching to temporary disk files. context | user vartype | integer source | default min_val | 64 max_val | 2147483647 enumvals | [NULL] boot_val | 4096 reset_val | 4096 sourcefile | [NULL] sourceline | [NULL] pending_restart | f  setting текущее значение параметра unit единица измерения, в нашем случае kB reset_val если параметр изменен во время сеанса, то можно вызвать reset и будет установлено это значение pending_restart обозначает необходимость перезапуска сервера для того, чтобы конфигурационный параметр применился(в нашей случае false, значит перезагружать сервер нет необходимости) context установлен user, обозначает, что пользователь в рамках своей сессии может изменить значение дананого параметра boot_val значение по умолчанию min_val, max_val минимальное-максимальное значение параметра Параметр context  Можно посмотреть список возможных значений параметра context   select distinct context from pg_settings; context ------------------- postmaster superuser-backend user internal backend sighup superuser (7 rows)  internal изменить нельзя никогда user может изменить пользователь в рамках своей сессии postmaster нужен перезапуск сервера для изменения значения sighup требуется перечитать файлы конфигурации superuser суперпользователь может изменить для своего сеанса    Попробуем изменить значения параметра work_mem  Изменим значение в конфигурационном файле work_mem = 24MB  Посмотрим значения в отображении pg_file_settings 127.0.0.1 postgres@postgres=# select * from pg_file_settings where name='work_mem'; sourcefile | sourceline | seqno | name | setting | applied | error --------------------------------------+------------+-------+----------+---------+---------+-------- /usr/local/psql/data/postgresql.conf | 122 | 3 | work_mem | 24MB | t | [NULL] (1 row) Видим, что значение установлено\n Посмотрим значение в pg_settings 127.0.0.1 postgres@postgres=# select setting from pg_settings where name='work_mem'\\gx -[ RECORD 1 ]- setting | 4096 Значение не поменялось\n Для того, чтобы изменить значение нужно выполнить select pg_reload_conf();  Посмотрим на параметр 127.0.0.1 postgres@postgres=# select setting from pg_settings where name='work_mem'\\gx -[ RECORD 1 ]-- setting | 24576 Изменился!\n  Изменение параметров без ручной правки конфигурационного файла Есть команда ALTER SYSTEM, которая позволяет изменить значение параметра прямо в sql. Будет создан новый конфигурационный файл postgresql.auto.conf, значения параметров там будут перекрывать значения в postgresql.conf\n Изменим work_mem 127.0.0.1 postgres@postgres=# alter system set work_mem to '10MB'; ALTER SYSTEM Time: 5.099 ms  Смотрим, не изменилось 127.0.0.1 postgres@postgres=# select setting from pg_settings where name='work_mem'\\gx -[ RECORD 1 ]-- setting | 24576  Нужно обновить конфиги select pg_reload_conf и значение изменится alter system reset work_mem очистит значение  Изменение значений параметров на время сессии  SET work_mem to '26MB' Проверим, видим, что значение изменилось, и что источник `` 127.0.0.1 postgres@postgres=# select * from pg_settings where name='work_mem'\\gx -[ RECORD 1 ]---+---------------------------------------------------------------------------------------------------------------------- name | work_mem setting | 26624 unit | kB category | Resource Usage / Memory short_desc | Sets the maximum memory to be used for query workspaces. extra_desc | This much memory can be used by each internal sort operation and hash table before switching to temporary disk files. context | user vartype | integer source | session   ","href":"/posts/storage/postgresql/configs/","title":"Конфигурирование postgresql"},{"content":"","href":"/tags/psql/","title":"psql"},{"content":"Работа с psql  Демо Слайды  Команды \\? список команд psql\n\\? variables переменные psql\n\\help показывает список команды, по которым можно получить документацию, например help alter table\n\\q выход\n\\conninfo информация о соединении\nYou are connected to database \u0026quot;postgres\u0026quot; as user \u0026quot;postgres\u0026quot; on host \u0026quot;127.0.0.1\u0026quot; at port \u0026quot;5432\u0026quot;. \\a включает/выключает выравнивание при выводе\n\\t включает/выключает вывод заголовков\n\\pset fielfsep ' ' устанавливает другой разделитель для строк, может использоваться для сохранения csv\n\\x расширенный вывод столбца\n\\set посмотреть список всех переменных\n\\set VAR1 text установка значения переменной\n\\echo :VAR1 вывод переменной\n\\d pg_tables показывает информацию о таблицах \\l показывает список баз данных\n\\c test подключается к базе данных test\nКонфигурационные файлы Общий конфигурационный файл pg_config --sysconfdir показывает директорию с настройками postgres\npg_config --sysconfdir /etc/postgresql В моём случае директория /etc/postgresql отсутствовала\nКонфигурационный файл конкретного пользователя Располагается в ~/.psqlrc\nПример файла от https://github.com/thoughtbot/dotfiles/blob/master/psqlrc\n-- Official docs: http://www.postgresql.org/docs/9.3/static/app-psql.html -- Unofficial docs: http://robots.thoughtbot.com/improving-the-command-line-postgres-experience -- Don't display the \u0026quot;helpful\u0026quot; message on startup. \\set QUIET 1 \\pset null '[NULL]' -- http://www.postgresql.org/docs/9.3/static/app-psql.html#APP-PSQL-PROMPTING \\set PROMPT1 '%[%033[1m%]%M %n@%/%R%[%033[0m%]%# ' -- PROMPT2 is printed when the prompt expects more input, like when you type -- SELECT * FROM\u0026lt;enter\u0026gt;. %R shows what type of input it expects. \\set PROMPT2 '[more] %R \u0026gt; ' -- Show how long each query takes to execute \\timing -- Use best available output format \\x auto \\set VERBOSITY verbose \\set HISTFILE ~/.psql_history- :DBNAME \\set HISTCONTROL ignoredups \\set COMP_KEYWORD_CASE upper \\unset QUIET Формат вывода С выравниванием (используется по умолчанию) 127.0.0.1 postgres@postgres=# SELECT schemaname, tablename, tableowner FROM pg_tables LIMIT 5; schemaname | tablename | tableowner ------------+-----------------+------------ pg_catalog | pg_statistic | postgres pg_catalog | pg_type | postgres pg_catalog | pg_policy | postgres pg_catalog | pg_authid | postgres pg_catalog | pg_user_mapping | postgres (5 rows) Без выравнивания \\a SELECT schemaname, tablename, tableowner FROM pg_tables LIMIT 5; schemaname|tablename|tableowner pg_catalog|pg_statistic|postgres pg_catalog|pg_type|postgres pg_catalog|pg_policy|postgres pg_catalog|pg_authid|postgres pg_catalog|pg_user_mapping|postgres (5 rows) Time: 1.400 ms Без заголовков \\t Tuples only is on. 127.0.0.1 postgres@postgres=# SELECT schemaname, tablename, tableowner FROM pg_tables LIMIT 5; pg_catalog|pg_statistic|postgres pg_catalog|pg_type|postgres pg_catalog|pg_policy|postgres pg_catalog|pg_authid|postgres pg_catalog|pg_user_mapping|postgres Time: 1.326 ms Расширенный(вертикальный вывод столбца) \\x Expanded display is on. 127.0.0.1 postgres@postgres=# SELECT * FROM pg_tables WHERE tablename = 'pg_class'; -[ RECORD 1 ]----------- schemaname | pg_catalog tablename | pg_class tableowner | postgres tablespace | [NULL] hasindexes | t hasrules | f hastriggers | f rowsecurity | f Time: 1.754 ms Взаимодействие с ОС  Можно выполнять команды обычного shell \\! whoami ixpectus  Установка переменной окружения =\u0026gt; \\setenv TEST Hello  Запись результатов вывода в файл \\o some_file 127.0.0.1 postgres@postgres=# SELECT * FROM pg_tables WHERE tablename = 'pg_class'; Time: 1.532 ms 127.0.0.1 postgres@postgres=# На экран ничего не выведется данные запишутся в файл. Можно поменять разделители и получить csv файл\n  Запуск скриптов  Как подготовить простой скрипт \\t Tuples only is off. 127.0.0.1 postgres@postgres=# \\a Output format is aligned. 127.0.0.1 postgres@postgres=# \\t \\a Tuples only is on. Output format is unaligned. 127.0.0.1 postgres@postgres=# \\o ~/tmp/psql_script1 127.0.0.1 postgres@postgres=# SELECT 'SELECT '''||tablename||': ''|| count(*) FROM '||tablename||';' FROM pg_tables LIMIT 3; Time: 1.119 ms  В результате в файле ~/tmp/psql_script1 окажется набор sql запросов SELECT 'pg_statistic: '|| count(*) FROM pg_statistic; SELECT 'pg_type: '|| count(*) FROM pg_type; SELECT 'pg_policy: '|| count(*) FROM pg_policy;  Выполнить их можно разными способами  \\i ~/tmp/psql_script1 в запущенном psql подав на вход psql файл   psql -h 127.0.0.1 -f ~/tmp/psql_script1 ?column? ------------------- pg_statistic: 393 (1 row) Time: 0.602 ms ?column? -------------- pg_type: 375 (1 row) Time: 0.212 ms ?column? -------------- pg_policy: 0 (1 row) Time: 0.220 ms Видно, что тут нет настроек \\t \\a и в заголовке выводится странная запись ?column?, можно в начале скрипта добавить \\t \\a \n подать файл на вход можно другим синтаксисом ``psql -h 127.0.0.1 \u0026lt; ~/tmp/psql_script1    Переменные  \\set посмотреть список всех переменных \\set VAR1 text установка значения переменной \\echo :VAR1 вывод переменной \\unset :VAR1 сбросить значение переменной SELECT now() AS curr_time \\gset можно результат запроса сразу установить в переменную \\echo :curr_time В переменную можно записать запрос и потом его выполнять \\set top5 'SELECT tablename, pg_total_relation_size(schemaname||''.''||tablename) AS bytes FROM pg_tables ORDER BY bytes DESC LIMIT 5;' :top5 Можно полезные запросы записывать в .psqlrc\n  Как подключиться к базе и сделать запрос psql -h 127.0.0.1 -d test -c 'select count(*) from some_table;';  Флаг -c обозначает команду, которую нужно выполнить Флаг -d обозначает базу, к которой нужно подключиться  ","href":"/posts/storage/postgresql/psql/","title":"psql"},{"content":"Установка из исходников  Где скачать Делаю по инструкции  Сам процесс установки tar -xzf postgresql-10.0.tar.gz cd ./postgresql-10.0.0 ./configure С версией 10.0.0 возникла ошибка при установке\ncopy_fetch.c:161:1: error: conflicting types for ‘copy_file_range’ copy_file_range(const char *path, off_t begin, off_t end, bool trunc) Взял версию 10.0.13. Всё установилось, но не был создан пользователь postgres, от имени которого должен запускаться сам postgres. Добавил его руками\nsudo useradd postgres sudo passwd postgres sudo mkdir /home/postgres sudo chown postgres /home/postgres su postgres Последним шагом вошёл в систему от имени пользователя postgres и добавил в .bashrc\nexport PGDATA=\u0026quot;/usr/local/psql/data\u0026quot; export PATH=$PATH:/usr/local/pgsql/bin/; Добавление psql директории для хранения данных sudo mkdir /usr/local/psql/ sudo chown postgres /usr/local/psql/ После добавление директории psql нужно выполнить от имени пользователя postgres initdb -k\nЗапуск сервера pg_ctl -w -l /home/postgres/logfile -D /usr/local/psql/data start Postgresql стартовал\nps aux | grep postgres ... postgres 102850 0.0 0.0 160184 2736 ? Ss 10:44 0:00 postgres: checkpointer process postgres 102851 0.0 0.0 160184 5004 ? Ss 10:44 0:00 postgres: writer process postgres 102852 0.0 0.0 160184 8516 ? Ss 10:44 0:00 postgres: wal writer process postgres 102853 0.0 0.0 160596 5804 ? Ss 10:44 0:00 postgres: autovacuum launcher process postgres 102854 0.0 0.0 15132 2644 ? Ss 10:44 0:00 postgres: stats collector process ... Но не удаётся подключится к нему\npsql psql: error: could not connect to server Попробовал скопировать конфиги и поменять listen_addresses\nsudo cp /usr/local/pgsql/share/postgresql.conf.sample /usr/local/pgsql/share/postgresql.conf Нужно было указать host\npsql -h 127.0.0.1 Установка расширения pgcrypto cd ./postgresql-10.13/contrib/pgcrypto make sudo make install Установка прошли успешно, проверяем установленные расширения\nselect * from pg_available_extensions; name | default_version | installed_version | comment ----------+-----------------+-------------------+------------------------------ plpgsql | 1.0 | 1.0 | PL/pgSQL procedural language pgcrypto | 1.3 | | cryptographic functions (2 rows) Установка всех расширений из директории contrib cd ./postgresql-10.13/contrib/ sudo make install name | default_version | installed_version | comment --------------------+-----------------+-------------------+---------------------------------------------------------------------- pg_prewarm | 1.1 | | prewarm relation data earthdistance | 1.1 | | calculate great-circle distances on the surface of the Earth tsm_system_time | 1.0 | | TABLESAMPLE method which accepts time in milliseconds as a limit plpgsql | 1.0 | 1.0 | PL/pgSQL procedural language pg_freespacemap | 1.2 | | examine the free space map (FSM) hstore | 1.4 | | data type for storing sets of (key, value) pairs pgstattuple | 1.5 | | show tuple-level statistics unaccent | 1.1 | | text search dictionary that removes accents chkpass | 1.0 | | data type for auto-encrypted passwords moddatetime | 1.0 | | functions for tracking last modification time tcn | 1.0 | | Triggered change notifications citext | 1.4 | | data type for case-insensitive character strings pageinspect | 1.6 | | inspect the contents of database pages at a low level tsm_system_rows | 1.0 | | TABLESAMPLE method which accepts number of rows as a limit amcheck | 1.0 | | functions for verifying relation integrity intagg | 1.1 | | integer aggregator and enumerator (obsolete) lo | 1.1 | | Large Object maintenance refint | 1.0 | | functions for implementing referential integrity (obsolete) btree_gist | 1.5 | | support for indexing common datatypes in GiST ltree ... Остановка сервера pg_ctl stop -m fast Можно написать просто pg_ctl stop, по умолчанию режим остановки как раз буде fast. Режимы остановки\n fast принудительно завершает все сеансы и записывает на диск изменения из оперативной памяти smart ожидает завершения всех сеансов и записывает на диск изменения из оперативной памяти immediate принудительно завершает сеансы, при запуске потребуется восстановление Получается immediate не записывает изменения из оперативной памяти, но не понятно какого рода восстановление понадобится после запуска. После запуска потребуется прочитать записи из WAL с прошлого checkpoint и применить их  ","href":"/posts/storage/postgresql/install/","title":"Install"},{"content":"Хорошие курсы от команды postgrespro и Олега Бартунова\n Администрирование PostgreSQL 10. Базовый курс Администрирование PostgreSQL 9.5. Расширенный курс Разработка серверной части приложений PostgreSQL 9.6. Базовый курс  ","href":"/posts/storage/postgresql/courses/","title":"курсы по postgresql"},{"content":"ARP  Address resolution protocol В локальной сети по ip с помощью arp как-то определяется mac адрес и обращение идёт по нему  Call example sudo arp-scan 192.168.4.0/24 [sudo] пароль для ixpectus: Interface: enp3s0, datalink type: EN10MB (Ethernet) Starting arp-scan 1.9 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/) 192.168.4.1 00:19:bb:c5:3e:02 Hewlett-Packard Company 192.168.4.2 20:cf:30:f1:fd:58 ASUSTek COMPUTER INC. 192.168.4.6 00:30:48:62:5e:aa Supermicro Computer, Inc. 192.168.4.7 00:25:90:92:68:97 Super Micro Computer, Inc. 192.168.4.8 00:30:48:d4:1e:86 Supermicro Computer, Inc. 192.168.4.9 e8:40:f2:0c:2f:a5 PEGATRON CORPORATION 192.168.4.10 6c:62:6d:aa:3b:2e Micro-Star INT'L CO., LTD 192.168.4.11 52:54:00:94:1f:61 QEMU ","href":"/posts/administrate/networking/arp/","title":"arp"},{"content":"","href":"/tags/cli/","title":"cli"},{"content":"dd умеет читать побайтово с устройства\nflags  if откуда читать of куда писать bs сколько бит читать  example прочитает первые 512 бит диска /dev/sda\nsudo dd uf=/dev/sda bs=512 How to calculate read/write speed  dd if=/dev/zero of=~/test.tmp bs=500K count=1024 sync; echo 3 | sudo tee /proc/sys/vm/drop_caches reset cache dd if=~/test.tmp of=/dev/null bs=500K count=1024 write  ","href":"/posts/linux/tools/dd/","title":"dd"},{"content":"","href":"/tags/linux/","title":"linux"},{"content":"","href":"/tags/network/","title":"network"},{"content":"","href":"/posts/administrate/networking/","title":"networking"},{"content":"","href":"/","title":""},{"content":"","href":"/search/","title":""},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/series/","title":"Series"}]
