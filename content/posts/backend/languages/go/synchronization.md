---
title: "Синхронизация в go"
date: 2022-07-25T14:13:20+03:00
tags:
  - go 
summary: "Синхронизация в go. Краткий обзор"
---
## О чём вообще речь 
В go есть возможность запустить несколько горутин, у которых будет общая область памяти.  
Для сценариев, когда нужно делать какую-то совместную работу необходима синхронизация между разными горутинами  
Что может произойти если это не делать или делать это плохо
- горутины будут друг друга бесконечно ждать(дедлок)
- горутины могут изменить одну и ту же область памяти, в результате работа каждой из них может стать некорректной

### Простым языком 
- Горутины это просто исполнители
- Задача условного "менеджера" обеспечить, чтобы они работали эффективно, не мешали, а помогали друг другу
- Но эти исполнители максимально "тупые", что им скажешь, то они и будут делать, они не будут друг с другом "общаться" 
- Сценарий взаимодействия этих исполнителей зависит от того, какой тип работы они будут делать

### Какие типы работы могут быть
- Все работы делятся в начале и далее, работы идёт независимо каждым исполнителем. Сценарий __map-reduce__
  - Работа делится на несколько независимых частей
  - Каждому исполнителю нужно дать работу
  - __Синхронизация__ нужна на этапе завершения работ
  - На этапе завершения исполнитель как-то должен передать работу "менеджеру"

## Каналы 
- Когда использовать
  - Когда нужна координация/передача информации между разными исполнителями
  - Когда происходит какая-то совместная обработка данных
- У канала есть 2 стороны
  - Тот, кто читает из канала и что-то с этим делает
    - Тот, кто читает из канала не должен его закрывать, поскольку другие могут из него читать, это не по-человечески
  - Тот, кто пишет в канал
    - Может его закрыть, когда всё что нужно уже записано 
    - Закрытие не должно происходить моментально, чтобы все читатели сумели обработать данные
- Какие могут возникнуть проблемы
  - Когда кто-то будет писать в закрытый канал, то будет паника
  - Если канал закрыть 2 раза, то будет паника

## Устройство каналов 
### Исходный код 
[github](https://github.com/golang/go/blob/release-branch.go1.17/src/runtime/chan.go#L32)
```go
type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16
	closed   uint32
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G's status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.
	lock mutex
}

type waitq struct {
	first *sudog
	last  *sudog
}
```

### Из чего состоит канал 
- `recvq waitq` очередь горутин, которые хотят что-то прочитать из канала
- `sendq waitq` очередь горутин, которые хотят что-то записать в канал
- `buf unsafe.Pointer ` указатель на данные в канале `circular queue`
- `lock mutex` мьютекс, перед всеми операциями с каналами он защищается мьютексом

## Waitgroup 
- Позволяет запустить 5 горутин и дождаться выполнения их всех

## Пакет atomic 
- Позволяет делает разнообразные атомарные операции над разными структурами


### Ссылки 
- [Подробно о каналах](https://go101.org/article/channel.html)
- [Сценарии использования каналов](https://go101.org/article/channel-use-cases.html)
