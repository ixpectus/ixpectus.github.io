---
title: "Буфферный кэш"
date: 2020-06-24T10:09:28+03:00
tags:
  - postgresql
  - buffer cache
summary: "При чтении страниц с диска postgresql пытается извлечь их из буфферного кэша, если страниц в кэше нет, то postres читает их с диска и помещает в кэш"
---

* [Демо](https://edu.postgrespro.ru/dba1/dba1_06_arch_wal.html)
* [Слайды](https://edu.postgrespro.ru/dba1/dba1_06_arch_wal.pdf)

#### Буфферный кэш
Процесс работы с диском выглядит как-то так
* Postrges понимает, что нужны какие-то данные с диска
* Postrges идёт сначала в некий кэш, в который помещает страницы после чтения с диска(буфферный кэш)
* Если данные в кэше есть, то они берутся из кэша, если в кэше данных нет, то они берутся с диска и помещаются в кэш
* Получить данные из кэша дешевле чем с диска, но поскольку кэш находится в общей памяти, то его необходимо защищать блокировками, и поэтому взять данные из кэша медленнее, чем просто из памяти
* После изменения данные также записываются сначала в буфферный кэш
* Фоновый процесс периодически записывает данные из буфферного кэша на диск(работает вытеснение LRU)

#### WAL 
В случае сбоя данные из буфферного кэша могут потеряться, и если ничего не предпринять, то они исчезнут насовсем.
Решение - **WAL**
Как и в других БД в postrgesql присутствует WAL(Write Ahead Log). Сначала данные попадают в него, а уже потом в файл с данными. 
Казалось бы почему сразу не записать данные в файл с данными. Пишут в WAL, т.к. это гораздо быстрее, запись делается просто в конец файла, это работает быстро как на SSD, так и на HDD.
WAL прежде всего нужен для восстановления после сбоя. И когда данные уже оказались на диске в файле с данными, то их из WAL можно удалять. 
За это отвечает `checkpointer process`, а за запись в WAL отвечает `wal writer process`

##### Режимы работы WAL 
В случае, если данные записались в WAL не факт, что они реально попадут на диск, т.к. есть ещё кэш операционной системы.
Для того, чтобы данные попали на диск нужно сделать системный вызов fsync, и тут есть 2 вариант
* Синхронный - fsync делается при каждой записи в WAL
* Асинхронный - fsync делается периодические процессом `wal writer process`, это менее надёжно, но быстрее

#### Checkpointer process(контрольная точка)
Проблема - если ничего не предпринимать, то WAL вырастет до огромных размеров и нужно будет каждый раз перечитывать его весь при сбоях.
Решение - сохранять некие контрольные точки(в каком только виде) для журнала, в которых все данные с журнала уже есть на диске.
Периодически все данные из буфферов полностью записываются на диск и создаётся контрольная точка.
Это делает `checkpointer process`. Если бы данные на диск записывал только этот процесс, то работал бы очень долго.
Есть ещё `writer process`, которые записывает на диск страницы, которые должны вытеснится 

#### LSN 
Каждая запись в журнале имеет номер LSN (Log Sequence Number). 
```
SELECT pg_current_wal_lsn();
 pg_current_wal_lsn
--------------------
 0/2823EA8
(1 row)
```
Можно посмотреть, как меняется этот номер при вставке каких-нибудь данных
* Сохраним текущий lsn
  ```
  127.0.0.1 postgres@test=# SELECT pg_current_wal_lsn() AS pos1 \gset
  Time: 0.586 ms
  127.0.0.1 postgres@test=# select :'pos1'::pg_lsn;
    pg_lsn
  -----------
   0/2826B70
  (1 row)
  ```
* Вставим данные и посмотрим на новый lsn
  ```
  insert into some_table(id) values(3);
  INSERT 0 1
  Time: 2.196 ms
  127.0.0.1 postgres@test=# SELECT pg_current_wal_lsn() AS pos2 \gset
  Time: 0.602 ms
  127.0.0.1 postgres@test=# select :'pos2'::pg_lsn;
    pg_lsn
  -----------
   0/2826DD8
  (1 row)
   
  Time: 0.579 ms
  127.0.0.1 postgres@test=# SELECT :'pos2'::pg_lsn - :'pos1'::pg_lsn;
   ?column?
  ----------
        616
  (1 row)
  ```
  Видно, что разница в записях 616 байт

Также можно что-то узнать о журналах, сделав запрос
```
SELECT * FROM pg_ls_waldir() ORDER BY name;
           name           |   size   |      modification
--------------------------+----------+------------------------
 000000010000000000000002 | 16777216 | 2020-06-24 10:41:37+03
 000000010000000000000003 | 16777216 | 2020-06-23 10:51:02+03
(2 rows)
 
 ```
