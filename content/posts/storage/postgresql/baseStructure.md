---
title: "Общее устройство postgresql"
date: 2020-06-20T22:50:08+03:00
tags:
  - postgresql
  - архитектура
summary: "Верхнеуровневое описание устройства postgresql и его основных процессов"
---
* [Слайды](https://edu.postgrespro.ru/dba1/dba1_04_arch_general.pdf)
* [Подробное описание работы с WAL в postgres](https://www.interdb.jp/pg/pgsql09.html)

### Описание устройства в целом 
В целом, как и у любой бд есть
* клиент
* сервер
* протокол взаимодействия клиента и сервера
* сервер умеет
  * разбирать запрос
  * формировать план выполнения
  * выполнять запрос

#### Интересные нюансы postgresql
* postgresql создаёт по процессу на каждое клиентское соединение
* если клиент решит использовать подготовленный запрос(prepared statement), то он может это сделать и его prepared statement должен будет обработать именно созданный под этого клиента процесс
* место, необходимое для выполнения запроса(план запроса, prepared statement, позиция курсора) хранится в памяти порождённого обслуживающего процесса. 
  * Это важный момент. Дело в том, что postgresql не очень хорошо обрабатывает большое количество соединений и вместе с ним как правило используют некое proxy, которое держит пул коннектов к postgresql.  
  Это приводит к тому, что использовать prepared statement становится затруднительно, т.к. приложение при следующем запросе может быть обслужено другим соединением из пула соединений, которое ничего не знает о его прошлом запросе

#### Как обеспечивается durability 
Работа происходит следующим образом
- При записи на диск сначала проверяется есть ли в shared buffers нужная страница
- Если она в памяти она есть, то страница изменяется и становится dirty page
- Запись помещается в wal buffer
- Когда происходит транзакция запись из wal buffer может попасть в wal segments уже на диске
- Запись wal на диск в общем случае происходит не сразу, wal writer process делает это в фоне
Как было раньше без wal ?
- Данные сразу записывались на диск
Можно ли писать в wal сразу после не в фоне
- Можно, но за счет того, что это происходит в фоне нагрузка на диск размазывается, запись производится пачками, производительность улучшается

#### Основные процессы в postgresql 
Работу postgresql обеспечивает ряд процессов ОС

##### Посмотрим, что это за процессы 
```
> ps -axo pid,ppid,command | grep post
1295940 1283863 vim /usr/local/psql/data/postgresql.conf
1310877       1 /usr/local/pgsql/bin/postgres
1310879 1310877 postgres: checkpointer process
1310880 1310877 postgres: writer process
1310881 1310877 postgres: wal writer process
1310882 1310877 postgres: autovacuum launcher process
1310883 1310877 postgres: stats collector process
1310884 1310877 postgres: bgworker: logical replication launcher
1311013 1310877 postgres: postgres postgres 127.0.0.1(48512) idle
```
По названию можно предположить, что
* `/ust/local/psql/bin/postgres` основной процесс, который породил остальные процессы, видно что parent id у них 1310877
* `wal writer process` отвечает за запись данных в write ahead log
* `autovacuum launcher process` запускает процесс autovacuum(очистки устаревших данных)
* `stats collector process` видимо отвечает за сбор статистики, которая в дальнейшем будет использоваться при построении плана выполнения запроса
* ради интереса убьём процесс `autovacuum launcher process` и посмотрим что сделает основной процесс postgres
  ```
  ~ sudo kill -9 1310882
  ~ ps -axo pid,ppid,command | grep post
  1295940 1283863 vim /usr/local/psql/data/postgresql.conf
  1310877       1 /usr/local/pgsql/bin/postgres
  1355751 1310877 postgres: checkpointer process
  1355752 1310877 postgres: writer process
  1355753 1310877 postgres: wal writer process
  1355754 1310877 postgres: autovacuum launcher process
  1355755 1310877 postgres: stats collector process
  ```
  Видно, что postgres перезапустил все остальные процессы(это понятно по сменившимся pid)

##### Описание основных процессов  
* `postmaster` самый главный процесс
  * порождает остальные процессы и следит за ними. В случае, если какой-то процесс аварийно завершает работу, то он может перезапустить как один процесс, так и вообще все процессы(что было видно выше)
  * выделяет общую память, к которой могут получить доступ другие процессы
  * слушает входящие соединения клиентов и порождает процессы, который будут обрабатывать клиентские запросы, эти порожденные запросы выглядят так в команде ps
  ```
  1370265 1310877 postgres: postgres postgres 127.0.0.1(52834) idle
  ```
* `wal writer process` обходит wal buffers, находит dirty pages и записывает данные на диск(wal segments)
* `autovacuum launcher process` запускает дополнительные процессы, которые начинают заниматься вакуумом(удалением неактуальных версий строк, сборкой мусора)
* `writer process` обходит страницы в shared buffer и записывает их на диск, используется алгоритм arc

##### Процессы обработчики запросов 
На каждое подключение клиента postgres создаёт отдельный процесс, который обслуживает этого клиента. До определённого момента(говорят до тысячи соединений) это работает неплохо, но больше postgresql не тянет и используют сторонние решения, которые держат пул коннектов к базе и управляют им (например pgbouncer)

##### MVCC 
Postgres использует multi version concurrency control для консистентной работы множества процессов с одними и теми же данными. Клиент в момент подключения получает некий идентификатор транзакции и при чтении получает записи из таблиц, соответствующие этому идентификатору.
Т.е. postgres хранит сразу несколько версий строк, при каждом изменении создаётся новая версия строки
И в какой-то момент нужно удалять версии строк, который никому не нужны, за это как раз отвечает процесс autovacuum

##### Кэширование 
Postgresql кэширует данные в памяти, а с диском работает через системные вызовы OS, и эти системные вызовы используют кэш ОС. Т.е. фактически получается двойной кэш, этим postgresql отличается от MySQL, которые не использует кэш ОС

